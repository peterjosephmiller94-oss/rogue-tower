
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Rogue Tower</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #111;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: auto;
      background: #222;
      touch-action: none;
    }
    #ui, #menu {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 8px;
    }
    .button {
      margin: 5px;
      padding: 6px 12px;
      background: #444;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .button:hover {
      background: #666;
    }
    #floating-damage {
      position: absolute;
      pointer-events: none;
      z-index: 20;
    }
    .damage {
      position: absolute;
      font-size: 14px;
      color: yellow;
      animation: floatUp 1s ease-out forwards;
    }
    @keyframes floatUp {
      0% { opacity: 1; transform: translateY(0); }
      100% { opacity: 0; transform: translateY(-30px); }
    }
  </style>
</head>
<body>
  <div id="menu">
    <button class="button" onclick="startGame()">Start Game</button>
    <button class="button" onclick="loadGame()">Load Game</button>
    <button class="button" onclick="muteToggle()">Toggle Music</button>
  </div>

  <div id="ui" style="display:none">
    <button class="button" onclick="placeTower('basic')">Place Basic Tower</button>
    <button class="button" onclick="placeTower('sniper')">Place Sniper Tower</button>
    <div>
      <strong>Shop:</strong>
      <button class="button" onclick="buyUpgrade('range')">+Range (25g)</button>
      <button class="button" onclick="buyUpgrade('damage')">+Damage (30g)</button>
    </div>
    <div>
      Gold: <span id="gold">100</span> |
      Lives: <span id="lives">10</span> |
      XP: <span id="xp">0</span> |
      Level: <span id="level">1</span>
    </div>
    <button class="button" onclick="saveGame()">Save</button>
    <button class="button" onclick="resetGame()">Restart</button>
  </div>

  <div id="floating-damage"></div>
  <canvas id="gameCanvas" width="480" height="640"></canvas>
  <audio id="bgm" loop>
    <source src="https://upload.wikimedia.org/wikipedia/commons/4/4e/Bossa_Antigua.mp3" type="audio/mpeg">
  </audio>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const tileSize = 40;
    const mapWidth = 12, mapHeight = 16;
    let grid = [], towers = [], enemies = [], projectiles = [], path = [];
    let gold = 100, lives = 10, xp = 0, level = 1, wave = 0;
    let upgrades = { range: 0, damage: 0 };
    let gameInterval, spawnInterval, gameStarted = false;

    const audio = document.getElementById("bgm");
    let muted = false;

    function muteToggle() {
      muted = !muted;
      audio.muted = muted;
    }

    function showDamage(x, y, amount) {
      const dmg = document.createElement("div");
      dmg.textContent = amount;
      dmg.className = "damage";
      dmg.style.left = `${x}px`;
      dmg.style.top = `${y}px`;
      document.getElementById("floating-damage").appendChild(dmg);
      setTimeout(() => dmg.remove(), 1000);
    }

    function initGrid() {
      grid = Array.from({ length: mapHeight }, (_, y) =>
        Array.from({ length: mapWidth }, (_, x) => ({ x, y }))
      );
    }

    function buildPath() {
      path = [
        {x:0,y:8},{x:1,y:8},{x:2,y:8},{x:2,y:7},{x:2,y:6},
        {x:3,y:6},{x:4,y:6},{x:5,y:6},{x:6,y:6},{x:6,y:7},
        {x:6,y:8},{x:7,y:8},{x:8,y:8},{x:9,y:8},{x:10,y:8},{x:11,y:8}
      ];
    }

    function placeTower(type) {
      canvas.onclick = function(evt) {
        const rect = canvas.getBoundingClientRect();
        const mx = evt.clientX - rect.left;
        const my = evt.clientY - rect.top;
        const tx = Math.floor(mx / tileSize);
        const ty = Math.floor(my / tileSize);
        if (!path.some(p => p.x === tx && p.y === ty)) {
          towers.push({x: tx, y: ty, type, cooldown: 0});
          gold -= 25;
          updateUI();
          canvas.onclick = null;
        }
      };
    }

    function buyUpgrade(type) {
      const cost = type === "range" ? 25 : 30;
      if (gold >= cost) {
        upgrades[type]++;
        gold -= cost;
        updateUI();
      }
    }

    function spawnEnemy() {
      enemies.push({x: 0, y: 8, pathIndex: 0, hp: 10 + wave * 2});
    }

    function moveEnemies() {
      enemies.forEach(e => {
        const t = path[e.pathIndex + 1];
        if (!t) {
          lives--;
          enemies = enemies.filter(en => en !== e);
          updateUI();
          return;
        }
        const dx = t.x - e.x, dy = t.y - e.y;
        e.x += dx * 0.05;
        e.y += dy * 0.05;
        if (Math.abs(e.x - t.x) < 0.1 && Math.abs(e.y - t.y) < 0.1) e.pathIndex++;
      });
    }

    function towerAttack() {
      towers.forEach(t => {
        if (t.cooldown > 0) return t.cooldown--;
        const range = 2 + upgrades.range * 0.5;
        const dmg = 5 + upgrades.damage * 2;
        const tgt = enemies.find(e => Math.hypot(e.x - t.x, e.y - t.y) < range);
        if (tgt) {
          projectiles.push({x: t.x, y: t.y, target: tgt, damage: dmg});
          t.cooldown = t.type === 'sniper' ? 60 : 30;
        }
      });
    }

    function updateProjectiles() {
      projectiles.forEach(p => {
        const dx = p.target.x - p.x;
        const dy = p.target.y - p.y;
        p.x += dx * 0.2;
        p.y += dy * 0.2;
        if (Math.abs(p.x - p.target.x) < 0.2 && Math.abs(p.y - p.target.y) < 0.2) {
          p.target.hp -= p.damage;
          const px = p.target.x * tileSize + tileSize/2;
          const py = p.target.y * tileSize;
          showDamage(px, py, p.damage);
          if (p.target.hp <= 0) {
            enemies = enemies.filter(e => e !== p.target);
            gold += 10;
            xp += 5;
            if (xp >= level * 20) {
              xp = 0; level++;
            }
            updateUI();
          }
          projectiles = projectiles.filter(pr => pr !== p);
        }
      });
    }

    function updateUI() {
      document.getElementById("gold").textContent = gold;
      document.getElementById("lives").textContent = lives;
      document.getElementById("xp").textContent = xp;
      document.getElementById("level").textContent = level;
    }

    function saveGame() {
      const state = { gold, lives, xp, level, upgrades };
      localStorage.setItem("rogue_tower_save", JSON.stringify(state));
    }

    function loadGame() {
      const state = JSON.parse(localStorage.getItem("rogue_tower_save"));
      if (state) {
        gold = state.gold;
        lives = state.lives;
        xp = state.xp;
        level = state.level;
        upgrades = state.upgrades;
        updateUI();
        startGame();
      }
    }

    function resetGame() {
      clearInterval(gameInterval);
      clearInterval(spawnInterval);
      towers = []; enemies = []; projectiles = [];
      gold = 100; lives = 10; xp = 0; level = 1; wave = 0;
      upgrades = { range: 0, damage: 0 };
      updateUI();
      startGame();
    }

    function drawGrid() {
      for (let row of grid) {
        for (let tile of row) {
          ctx.fillStyle = path.some(p => p.x === tile.x && p.y === tile.y) ? '#333' : '#1a1a1a';
          ctx.fillRect(tile.x * tileSize, tile.y * tileSize, tileSize, tileSize);
          ctx.strokeStyle = '#000';
          ctx.strokeRect(tile.x * tileSize, tile.y * tileSize, tileSize, tileSize);
        }
      }
    }

    function drawTowers() {
      towers.forEach(t => {
        ctx.fillStyle = t.type === "sniper" ? "purple" : "blue";
        ctx.fillRect(t.x * tileSize + 10, t.y * tileSize + 10, 20, 20);
      });
    }

    function drawEnemies() {
      enemies.forEach(e => {
        ctx.fillStyle = "red";
        ctx.beginPath();
        ctx.arc(e.x * tileSize + tileSize/2, e.y * tileSize + tileSize/2, 10, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawProjectiles() {
      projectiles.forEach(p => {
        ctx.fillStyle = "yellow";
        ctx.beginPath();
        ctx.arc(p.x * tileSize + tileSize/2, p.y * tileSize + tileSize/2, 4, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGrid(); drawTowers(); drawEnemies(); drawProjectiles();
      moveEnemies(); towerAttack(); updateProjectiles();
      requestAnimationFrame(gameLoop);
    }

    function startGame() {
      if (gameStarted) return;
      document.getElementById("ui").style.display = "block";
      document.getElementById("menu").style.display = "none";
      initGrid(); buildPath(); gameLoop();
      gameStarted = true;
      audio.play();
      spawnInterval = setInterval(() => { spawnEnemy(); wave++; }, 4000);
    }
  </script>
</body>
</html>
