
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rogue Tower</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #111;
      color: #fff;
      font-family: 'Segoe UI', sans-serif;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: auto;
      background: #222;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 8px;
    }
    .button {
      margin: 5px;
      padding: 5px 10px;
      background: #444;
      color: #fff;
      border: none;
      cursor: pointer;
      border-radius: 4px;
    }
    .button:hover {
      background: #666;
    }
    #shop, #upgrades {
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div>
      <strong>Click a tile to place:</strong>
      <button class="button" onclick="selectedTowerType = 'basic'">Basic Tower (25g)</button>
      <button class="button" onclick="selectedTowerType = 'sniper'">Sniper Tower (25g)</button>
    </div>
    <div id="shop">
      <strong>Shop:</strong>
      <button class="button" onclick="buyUpgrade('range')">+Range (25g)</button>
      <button class="button" onclick="buyUpgrade('damage')">+Damage (30g)</button>
    </div>
    <div id="upgrades"></div>
    <div>
      Gold: <span id="gold">100</span>
      | Lives: <span id="lives">10</span>
      | XP: <span id="xp">0</span>
      | Level: <span id="level">1</span>
      | Wave: <span id="wave">0</span>
      <button class="button" onclick="togglePause()">Pause</button>
      <button class="button" onclick="saveGame()">ðŸ’¾ Save</button>
      <button class="button" onclick="loadGame()">ðŸ“‚ Load</button>
    </div>
  </div>
  <canvas id="gameCanvas" width="480" height="640"></canvas>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const tileSize = 40;
    const mapWidth = 12;
    const mapHeight = 16;
    let grid = [], towers = [], enemies = [], projectiles = [];
    let gold = 100, lives = 10, xp = 0, level = 1;
    let wave = 0, path = [];
    let upgrades = { range: 0, damage: 0 };
    let selectedTowerType = 'basic';
    let paused = false;

    function initGrid() {
      grid = Array.from({ length: mapHeight }, (_, y) => 
        Array.from({ length: mapWidth }, (_, x) => ({ x, y, walkable: true })));
    }

    function buildPath() {
      path = [
        {x: 0, y: 8}, {x: 1, y: 8}, {x: 2, y: 8},
        {x: 2, y: 7}, {x: 2, y: 6},
        {x: 3, y: 6}, {x: 4, y: 6}, {x: 5, y: 6}, {x: 6, y: 6},
        {x: 6, y: 7}, {x: 6, y: 8},
        {x: 7, y: 8}, {x: 8, y: 8}, {x: 9, y: 8}, {x: 10, y: 8}, {x: 11, y: 8},
      ];
    }

    function placeTowerClick(evt) {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((evt.clientX - rect.left) / tileSize);
      const y = Math.floor((evt.clientY - rect.top) / tileSize);
      if (!path.some(p => p.x === x && p.y === y) && gold >= 25) {
        towers.push({x, y, type: selectedTowerType, cooldown: 0});
        gold -= 25;
        updateUI();
      }
    }

    function buyUpgrade(type) {
      const cost = type === 'range' ? 25 : 30;
      if (gold >= cost) {
        upgrades[type]++;
        gold -= cost;
        document.getElementById("upgrades").textContent = `Upgrades: +Range(${upgrades.range}) +Damage(${upgrades.damage})`;
        updateUI();
      }
    }

    function spawnEnemy() {
      enemies.push({ x: 0, y: 8, pathIndex: 0, hp: 10 + wave * 2 });
    }

    function moveEnemies() {
      enemies.forEach(e => {
        const target = path[e.pathIndex + 1];
        if (!target) {
          lives--;
          enemies = enemies.filter(en => en !== e);
          updateUI();
          return;
        }
        const dx = target.x - e.x, dy = target.y - e.y;
        e.x += dx * 0.05;
        e.y += dy * 0.05;
        if (Math.abs(e.x - target.x) < 0.1 && Math.abs(e.y - target.y) < 0.1) e.pathIndex++;
      });
    }

    function towerAttack() {
      towers.forEach(t => {
        if (t.cooldown > 0) return t.cooldown--;
        const range = 2 + upgrades.range * 0.5;
        const damage = 5 + upgrades.damage * 2;
        const target = enemies.find(e => Math.hypot(e.x - t.x, e.y - t.y) < range);
        if (target) {
          projectiles.push({ x: t.x, y: t.y, target, damage });
          t.cooldown = t.type === 'sniper' ? 60 : 30;
        }
      });
    }

    function updateProjectiles() {
      projectiles.forEach(p => {
        const dx = p.target.x - p.x, dy = p.target.y - p.y;
        p.x += dx * 0.1;
        p.y += dy * 0.1;
        if (Math.abs(p.x - p.target.x) < 0.2 && Math.abs(p.y - p.target.y) < 0.2) {
          p.target.hp -= p.damage;
          if (p.target.hp <= 0) {
            enemies = enemies.filter(e => e !== p.target);
            gold += 10;
            xp += 5;
            if (xp >= level * 20) {
              xp = 0;
              level++;
            }
            updateUI();
          }
          projectiles = projectiles.filter(pr => pr !== p);
        }
      });
    }

    function updateUI() {
      document.getElementById("gold").textContent = gold;
      document.getElementById("lives").textContent = lives;
      document.getElementById("xp").textContent = xp;
      document.getElementById("level").textContent = level;
      document.getElementById("wave").textContent = wave;
    }

    function saveGame() {
      const saveData = { gold, lives, xp, level, wave, upgrades };
      localStorage.setItem('rogueTowerSave', JSON.stringify(saveData));
    }

    function loadGame() {
      const saveData = JSON.parse(localStorage.getItem('rogueTowerSave'));
      if (saveData) {
        gold = saveData.gold;
        lives = saveData.lives;
        xp = saveData.xp;
        level = saveData.level;
        wave = saveData.wave;
        upgrades = saveData.upgrades;
        updateUI();
      }
    }

    function togglePause() {
      paused = !paused;
    }

    function drawGrid() {
      grid.forEach(row => row.forEach(tile => {
        ctx.fillStyle = path.some(p => p.x === tile.x && p.y === tile.y) ? '#333' : '#1a1a1a';
        ctx.fillRect(tile.x * tileSize, tile.y * tileSize, tileSize, tileSize);
        ctx.strokeStyle = '#000';
        ctx.strokeRect(tile.x * tileSize, tile.y * tileSize, tileSize, tileSize);
      }));
    }

    function drawTowers() {
      towers.forEach(t => {
        ctx.fillStyle = t.type === 'sniper' ? 'purple' : 'blue';
        ctx.fillRect(t.x * tileSize + 10, t.y * tileSize + 10, 20, 20);
      });
    }

    function drawEnemies() {
      enemies.forEach(e => {
        ctx.fillStyle = 'red';
        ctx.beginPath();
        ctx.arc(e.x * tileSize + tileSize/2, e.y * tileSize + tileSize/2, 10, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawProjectiles() {
      projectiles.forEach(p => {
        ctx.fillStyle = 'yellow';
        ctx.beginPath();
        ctx.arc(p.x * tileSize + tileSize/2, p.y * tileSize + tileSize/2, 4, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function gameLoop() {
      if (paused) return requestAnimationFrame(gameLoop);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawGrid();
      drawTowers();
      drawEnemies();
      drawProjectiles();
      moveEnemies();
      towerAttack();
      updateProjectiles();
      requestAnimationFrame(gameLoop);
    }

    canvas.addEventListener('click', placeTowerClick);
    initGrid();
    buildPath();
    updateUI();
    gameLoop();
    setInterval(() => { if (!paused) { spawnEnemy(); wave++; updateUI(); } }, 4000);
  </script>
</body>
</html>
